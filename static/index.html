<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>Realtime Trains – Corridor Timetable (All Services)</title>
    <style>
      body {
        font-family: system-ui, sans-serif;
        margin: 2rem;
        line-height: 1.4;
      }
      h1 {
        font-size: 1.6rem;
        margin-bottom: 0.25rem;
      }
      h2 {
        margin-top: 1.5rem;
      }
      label {
        display: inline-block;
        margin-right: 1rem;
        margin-top: 0.5rem;
      }
      input {
        padding: 0.25rem 0.4rem;
        font-size: 1rem;
        margin-left: 0.25rem;
      }
      input[type="text"] {
        width: 4rem;
        text-transform: uppercase;
      }
      input[type="date"] {
        width: 11rem;
      }
      input[type="time"] {
        width: 7rem;
      }
      button {
        margin-top: 0.75rem;
        padding: 0.4rem 0.8rem;
        font-size: 1rem;
        cursor: pointer;
      }
      #status {
        margin-top: 1rem;
        font-family: monospace;
        white-space: pre-wrap;
      }
      table {
        border-collapse: collapse;
        width: 100%;
        min-width: 40rem;
        font-size: 0.85rem;
        margin-bottom: 2rem;
      }
      th {
        border: 1px solid #ccc;
        padding: 0.25rem 0.4rem;
        text-align: center;
      }

      td {
        /* keep vertical gridlines */
        border-left: 1px solid #ccc;
        border-right: 1px solid #ccc;

        /* remove horizontal gridlines by default */
        border-top: none;
        border-bottom: none;

        padding: 0.25rem 0.4rem;
        text-align: center;
      }

      /* Add a horizontal line above rows that should have one:
       - below the header (first body row)
       - between arr and dep rows of the same station (dep row gets a top border)
    */
      tr.row-sep-top > td {
        border-top: 1px solid #ccc;
      }
      th.sticky-top {
        position: sticky;
        top: 0;
        background: #f0f0f0;
        z-index: 2;
      }
      th.sticky-left,
      td.sticky-left {
        position: sticky;
        left: 0;
        background: #f9f9f9;
        text-align: right;
        z-index: 3;
      }
      td.sticky-left.station-row-label {
        white-space: nowrap;
        width: max-content;
        min-width: max-content;
        text-align: right;
        padding-right: 0.5rem;
      }
      th.corner {
        z-index: 4;
      }
      .station-row-label {
        font-weight: 600;
      }
      .small {
        font-size: 0.9rem;
        color: #555;
        margin-top: 0.5rem;
        max-width: 60rem;
      }
      .time-empty {
        color: #ccc;
      }
      .service-header {
        font-weight: 600;
        white-space: nowrap;
        color: inherit;
        text-decoration: none;
      }
      .service-header:hover {
        text-decoration: underline;
      }

      /* --- icon header row --- */
      th.icon-row {
        font-weight: 600;
        padding: 0.15rem 0.4rem;
      }

      .icon-wrap {
        display: inline-flex;
        gap: 0.35rem;
        align-items: center;
        justify-content: center;
      }

      .fc-icon {
        display: inline-flex;
        width: 1.2rem;
        height: 1.2rem;
        border: 1px solid #666;
        border-radius: 999px;
        align-items: center;
        justify-content: center;
        font-size: 0.8rem;
        line-height: 1;
      }

      .bed-icon {
        display: inline-flex;
        width: 1.2rem;
        height: 1.2rem;
        align-items: center;
        justify-content: center;
      }

      .bed-icon svg {
        width: 1.1rem;
        height: 1.1rem;
        display: block;
      }
    </style>
  </head>
  <body>
    <h1>Realtime Trains – Corridor Timetable (All Services)</h1>
    <p class="small">
      Rows: stations between the two endpoints (each with <em>arr</em> and
      <em>dep</em>).<br />
      Columns: services that run along the corridor and call at
      <strong>at least two</strong> of these stations (including the
      endpoints).<br />
      Stations are derived from the union of calling points of services directly
      along the corridor (including any via stations), using the
      <code>/json/service/&lt;uid&gt;/&lt;date&gt;</code> API, and ignoring
      locations whose <code>displayAs</code> is <code>PASS</code> or
      <code>CANCELLED_PASS</code>.<br />
      Services are split into two tables by direction: A→B (where A occurs
      before B in the calling pattern) and B→A (where B occurs before A). For
      services starting/ending outside the corridor, the origin/destination CRS
      is shown in dedicated rows at the very top (“Comes from”) and/or very
      bottom (“Continues to”) if needed. Hover shows the full location name.
    </p>

    <form id="form">
      <label>
        From (CRS):
        <input type="text" id="fromCrs" maxlength="3" required />
      </label>

      <!-- "Add Via" button lives between From and To; Via labels are inserted above it -->
      <button type="button" id="addViaBtn">Add Via</button>

      <label>
        To (CRS):
        <input type="text" id="toCrs" maxlength="3" required />
      </label>
      <label>
        Date:
        <input type="date" id="serviceDate" required />
      </label>
      <label>
        Start time:
        <input type="time" id="startTime" required />
      </label>
      <label>
        End time:
        <input type="time" id="endTime" required />
      </label>
      <button type="submit">Build timetable</button>
    </form>

    <div id="status"></div>

    <h2 id="headingAB"></h2>
    <table>
      <thead>
        <tr id="header-row-ab"></tr>
        <tr id="header-icons-row-ab"></tr>
      </thead>
      <tbody id="body-rows-ab"></tbody>
    </table>

    <h2 id="headingBA"></h2>
    <table>
      <thead>
        <tr id="header-row-ba"></tr>
        <tr id="header-icons-row-ba"></tr>
      </thead>
      <tbody id="body-rows-ba"></tbody>
    </table>

    <script>
      const DEBUG_STATIONS = true; // set true to log station selection / dwell details

      // === PROXY ENDPOINTS ===
      const PROXY_SEARCH = "/rtt/search";
      const PROXY_SERVICE = "/rtt/service";

      const form = document.getElementById("form");
      const statusEl = document.getElementById("status");
      const headingAB = document.getElementById("headingAB");
      const headingBA = document.getElementById("headingBA");
      const headerRowAB = document.getElementById("header-row-ab");
      const bodyRowsAB = document.getElementById("body-rows-ab");
      const headerRowBA = document.getElementById("header-row-ba");
      const bodyRowsBA = document.getElementById("body-rows-ba");
      const addViaBtn = document.getElementById("addViaBtn");
      const headerIconsRowAB = document.getElementById("header-icons-row-ab");
      const headerIconsRowBA = document.getElementById("header-icons-row-ba");

      // Track dynamically-added via inputs
      const viaInputs = [];

      let currentDate = "";
      let startMinutes = null;
      let endMinutes = null;

      // === "Add Via" button behaviour ===
      addViaBtn.addEventListener("click", () => {
        createViaField("");
      });

      function createViaField(initialValue = "") {
        const label = document.createElement("label");
        label.textContent = "Via (CRS):";

        const input = document.createElement("input");
        input.type = "text";
        input.maxLength = 3;
        input.required = false;
        input.value = initialValue;
        input.style.marginRight = "0.25rem";

        // Small "×" button to remove this via
        const removeBtn = document.createElement("button");
        removeBtn.type = "button";
        removeBtn.textContent = "×";
        removeBtn.title = "Remove this via";
        removeBtn.style.marginLeft = "0.25rem";

        removeBtn.addEventListener("click", () => {
          // Remove from DOM
          label.remove();
          // Remove from tracking array
          const idx = viaInputs.indexOf(input);
          if (idx !== -1) {
            viaInputs.splice(idx, 1);
          }
        });

        label.appendChild(input);
        label.appendChild(removeBtn);

        // Insert the new Via label before the Add Via button, so we get:
        // Via
        // Via
        // [Add Via]
        form.insertBefore(label, addViaBtn);

        viaInputs.push(input);
      }

      function setCookie(name, value, days) {
        const d = new Date();
        d.setTime(d.getTime() + days * 24 * 60 * 60 * 1000);
        const expires = "expires=" + d.toUTCString();
        document.cookie =
          name +
          "=" +
          encodeURIComponent(value) +
          ";" +
          expires +
          ";path=/;SameSite=Lax";
      }

      function getCookie(name) {
        const decoded = decodeURIComponent(document.cookie || "");
        const parts = decoded.split(";");
        const prefix = name + "=";
        for (let c of parts) {
          c = c.trim();
          if (c.indexOf(prefix) === 0) {
            return c.substring(prefix.length);
          }
        }
        return "";
      }

      function loadSavedInputsFromCookies() {
        const from = getCookie("corridor_fromCrs");
        const to = getCookie("corridor_toCrs");
        const date = getCookie("corridor_serviceDate");
        const start = getCookie("corridor_startTime");
        const end = getCookie("corridor_endTime");
        const viasStr = getCookie("corridor_vias");

        if (from) document.getElementById("fromCrs").value = from;
        if (to) document.getElementById("toCrs").value = to;
        if (date) document.getElementById("serviceDate").value = date;
        if (start) document.getElementById("startTime").value = start;
        if (end) document.getElementById("endTime").value = end;

        // Default to NO vias on first run.
        // On subsequent runs, recreate one via field per saved CRS.
        if (viasStr) {
          viasStr
            .split(",")
            .map((v) => v.trim())
            .filter((v) => v)
            .forEach((v) => createViaField(v));
        }
      }

      // Run once when the script loads
      loadSavedInputsFromCookies();

      function htmlEscape(str) {
        return String(str)
          .replace(/&/g, "&amp;")
          .replace(/</g, "&lt;")
          .replace(/>/g, "&gt;")
          .replace(/"/g, "&quot;")
          .replace(/'/g, "&#39;");
      }

      function normaliseCrs(v) {
        return (v || "").trim().toUpperCase();
      }

      function padTime(str) {
        if (!str) return "";
        const s = String(str);
        if (s.length === 4) {
          return s.slice(0, 2) + ":" + s.slice(2);
        } else if (s.length === 6) {
          return s.slice(0, 2) + ":" + s.slice(2, 4);
        }
        return s;
      }

      function timeStrToMinutes(hhmm) {
        if (!hhmm) return null;
        const parts = hhmm.split(":");
        if (parts.length !== 2) return null;
        const h = parseInt(parts[0], 10);
        const m = parseInt(parts[1], 10);
        if (Number.isNaN(h) || Number.isNaN(m)) return null;
        return h * 60 + m;
      }

      function rttTimeToMinutes(hhmm) {
        if (!hhmm) return null;
        const s = String(hhmm);
        if (s.length !== 4) return null;
        const h = parseInt(s.slice(0, 2), 10);
        const m = parseInt(s.slice(2), 10);
        if (Number.isNaN(h) || Number.isNaN(m)) return null;
        return h * 60 + m;
      }

      function serviceInTimeRange(locationDetail) {
        if (!locationDetail) return false;
        const tStr =
          locationDetail.gbttBookedDeparture ||
          locationDetail.gbttBookedArrival ||
          locationDetail.realtimeDeparture ||
          locationDetail.realtimeArrival ||
          "";
        const mins = rttTimeToMinutes(tStr);
        if (mins === null) return false;
        return mins >= startMinutes && mins <= endMinutes;
      }

      function serviceAtStationInRange(service) {
        const ld = service.locationDetail || {};
        return serviceInTimeRange(ld);
      }

      function safePairText(pairs) {
        if (!Array.isArray(pairs) || !pairs[0]) return "";
        const p = pairs[0];
        const name = p.description || "";
        const time = p.publicTime ? padTime(p.publicTime) : "";
        return name + (time ? " " + time : "");
      }

      function setStatus(msg) {
        statusEl.textContent = msg;
      }

      form.addEventListener("submit", async (e) => {
        e.preventDefault();

        // Run HTML5 validation for "required" fields, min/max, etc.
        if (!form.reportValidity()) {
          return;
        }

        setStatus("");
        headerRowAB.innerHTML = "";
        bodyRowsAB.innerHTML = "";
        headerRowBA.innerHTML = "";
        bodyRowsBA.innerHTML = "";
        headingAB.textContent = "";
        headingBA.textContent = "";
        headerRowAB.innerHTML = "";
        headerIconsRowAB.innerHTML = "";
        bodyRowsAB.innerHTML = "";
        headerRowBA.innerHTML = "";
        headerIconsRowBA.innerHTML = "";
        bodyRowsBA.innerHTML = "";

        const from = normaliseCrs(document.getElementById("fromCrs").value);
        const to = normaliseCrs(document.getElementById("toCrs").value);
        const dateInput = document.getElementById("serviceDate").value;
        const startInput = document.getElementById("startTime").value;
        const endInput = document.getElementById("endTime").value;

        // Collect via CRS values (non-empty only)
        const viaValues = viaInputs
          .map((input) => normaliseCrs(input.value))
          .filter((v) => v);

        // Persist current form values + vias for next visit
        setCookie("corridor_fromCrs", from, 365);
        setCookie("corridor_toCrs", to, 365);
        setCookie("corridor_serviceDate", dateInput, 365);
        setCookie("corridor_startTime", startInput, 365);
        setCookie("corridor_endTime", endInput, 365);
        setCookie("corridor_vias", viaValues.join(","), 365);

        currentDate = dateInput;
        startMinutes = timeStrToMinutes(startInput);
        endMinutes = timeStrToMinutes(endInput);

        if (!from || !to) {
          setStatus("Please enter both From and To CRS codes.");
          return;
        }
        if (startMinutes === null || endMinutes === null) {
          setStatus("Please enter a valid time range.");
          return;
        }

        // Full corridor chain including vias
        const corridorStations = [from, ...viaValues, to];

        setStatus(
          "Step 1/4: Fetching corridor services for " +
            corridorStations.join(" \u2192 ") +
            " on " +
            currentDate +
            " between " +
            startInput +
            " and " +
            endInput +
            " ...",
        );

        // Legs: A->B, B->C, ..., for each adjacent pair in the corridor chain
        const corridorLegs = [];
        for (let i = 0; i < corridorStations.length - 1; i++) {
          corridorLegs.push({
            from: corridorStations[i],
            to: corridorStations[i + 1],
          });
        }

        // Step 1: fetch all corridor services across all legs, deduplicated by serviceUid|runDate
        const corridorServicesMap = new Map();

        try {
          const searchPromises = corridorLegs.map(async (leg) => {
            const url =
              PROXY_SEARCH +
              "?crs=" +
              encodeURIComponent(leg.from) +
              "&to=" +
              encodeURIComponent(leg.to) +
              "&date=" +
              encodeURIComponent(currentDate);
            const resp = await fetch(url, {
              headers: { Accept: "application/json" },
            });
            const text = await resp.text();
            let data;
            try {
              data = JSON.parse(text);
            } catch (e) {
              console.warn(
                "Failed to parse corridor search JSON for leg",
                leg,
                e,
                text,
              );
              return;
            }
            const services = Array.isArray(data.services) ? data.services : [];
            services.forEach((svc) => {
              if (svc.isPassenger === false) return;
              if (svc.plannedCancel) return;
              if (!serviceAtStationInRange(svc)) return;
              const key = (svc.serviceUid || "") + "|" + (svc.runDate || "");
              if (!corridorServicesMap.has(key)) {
                corridorServicesMap.set(key, svc);
              }
            });
          });

          await Promise.all(searchPromises);
        } catch (err) {
          setStatus("Error fetching initial corridor search results: " + err);
          return;
        }

        const corridorServices = Array.from(corridorServicesMap.values());

        if (corridorServices.length === 0) {
          setStatus(
            statusEl.textContent +
              "\nNo passenger services in this time range on corridor.",
          );
          return;
        }

        setStatus(
          statusEl.textContent +
            "\nStep 2/4: Fetching full details for " +
            corridorServices.length +
            " corridor services ...",
        );

        // Step 2: Get full details for corridor services to derive station union.
        const corridorDetailPromises = corridorServices.map(async (svc) => {
          const uid = svc.serviceUid;
          const date = svc.runDate;
          const url =
            PROXY_SERVICE +
            "?uid=" +
            encodeURIComponent(uid) +
            "&date=" +
            encodeURIComponent(date);
          const resp = await fetch(url, {
            headers: { Accept: "application/json" },
          });
          const text = await resp.text();
          let data;
          try {
            data = JSON.parse(text);
          } catch (e) {
            console.warn(
              "Failed to parse corridor service JSON for",
              uid,
              e,
              text,
            );
            data = null;
          }
          return {
            svc,
            detail: data,
            status: resp.status,
            statusText: resp.statusText,
            seed: true,
          };
        });

        let corridorDetails;
        try {
          corridorDetails = await Promise.all(corridorDetailPromises);
        } catch (err) {
          setStatus(
            statusEl.textContent +
              "\nError fetching corridor service details: " +
              err,
          );
          return;
        }

        const okCorridorDetails = corridorDetails.filter(
          (d) => d.detail && Array.isArray(d.detail.locations),
        );
        if (okCorridorDetails.length === 0) {
          setStatus(
            statusEl.textContent +
              "\nNo usable corridor service detail responses.",
          );
          return;
        }

        // Build station union from all corridor services, over the multi-via chain,
        // ignoring PASS / CANCELLED_PASS.
        const stations = buildStationsUnion(
          corridorStations,
          okCorridorDetails,
        );
        if (stations.length === 0) {
          setStatus(
            statusEl.textContent +
              "\nNo stations found between " +
              from +
              " and " +
              to +
              (viaValues.length ? " (via " + viaValues.join(", ") + ")" : "") +
              ".",
          );
          return;
        }
        const stationSet = {};
        stations.forEach((s) => {
          if (s.crs) stationSet[s.crs] = true;
        });

        setStatus(
          statusEl.textContent +
            "\nStep 3/4: Discovering all services at corridor stations ...",
        );

        // Build a candidate map of all services seen at any corridor station.
        const candidateMap = new Map(); // key -> { svc, detail, seed }

        function serviceKey(svc) {
          return (svc.serviceUid || "") + "|" + (svc.runDate || "");
        }

        // Seed with corridor services + their details.
        okCorridorDetails.forEach((entry) => {
          const key = serviceKey(entry.svc);
          candidateMap.set(key, {
            svc: entry.svc,
            detail: entry.detail,
            seed: true,
          });
        });

        // For each corridor station, search all services at that station (for the same date),
        // and filter by time range at that station.
        const stationSearchPromises = stations.map(async (st) => {
          const url =
            PROXY_SEARCH +
            "?crs=" +
            encodeURIComponent(st.crs) +
            "&date=" +
            encodeURIComponent(currentDate);
          const resp = await fetch(url, {
            headers: { Accept: "application/json" },
          });
          const text = await resp.text();
          let data;
          try {
            data = JSON.parse(text);
          } catch (e) {
            console.warn("Failed to parse search for station", st.crs, e, text);
            return;
          }
          const services = Array.isArray(data.services) ? data.services : [];
          services.forEach((svc) => {
            if (svc.isPassenger === false) return;
            if (svc.plannedCancel) return;
            if (!serviceAtStationInRange(svc)) return;
            const key = serviceKey(svc);
            if (!key) return;
            if (!candidateMap.has(key)) {
              candidateMap.set(key, { svc: svc, detail: null, seed: false });
            }
          });
        });

        try {
          await Promise.all(stationSearchPromises);
        } catch (err) {
          console.warn("Error during station searches:", err);
        }

        setStatus(
          statusEl.textContent +
            "\nStep 3/4: Found " +
            candidateMap.size +
            " candidate services; fetching details ...",
        );

        // Fetch details for candidates that don't already have them.
        const detailFetchPromises = [];
        for (const [key, entry] of candidateMap.entries()) {
          if (entry.detail) continue; // already have
          const uid = entry.svc.serviceUid;
          const date = entry.svc.runDate;
          if (!uid || !date) continue;
          const url =
            PROXY_SERVICE +
            "?uid=" +
            encodeURIComponent(uid) +
            "&date=" +
            encodeURIComponent(date);
          const p = fetch(url, { headers: { Accept: "application/json" } })
            .then((resp) =>
              resp.text().then((text) => {
                let data = null;
                try {
                  data = JSON.parse(text);
                } catch (e) {
                  console.warn(
                    "Failed to parse candidate service JSON for",
                    uid,
                    e,
                    text,
                  );
                }
                entry.detail = data;
              }),
            )
            .catch((err) => {
              console.warn(
                "Error fetching candidate service detail for",
                uid,
                err,
              );
            });
          detailFetchPromises.push(p);
        }

        try {
          await Promise.all(detailFetchPromises);
        } catch (err) {
          console.warn("Error during candidate detail fetch:", err);
        }

        // Filter to services that:
        //  - have valid detail.locations
        //  - and call at >= 2 *distinct* non-PASS corridor stations.
        // This removes loops like CTR→CTR that only ever touch one station in the table.
        const allDetails = [];
        for (const [key, entry] of candidateMap.entries()) {
          const detail = entry.detail;
          if (!detail || !Array.isArray(detail.locations)) continue;

          const locs = detail.locations;
          const seenStations = new Set();

          for (const l of locs) {
            const crs = l.crs || "";
            if (!stationSet[crs]) continue;

            const disp = (l.displayAs || "").toUpperCase();
            if (disp === "PASS" || disp === "CANCELLED_PASS") continue; // only calling points

            seenStations.add(crs);
            if (seenStations.size >= 2) break;
          }

          if (seenStations.size >= 2) {
            allDetails.push(entry);
          }
        }

        if (allDetails.length === 0) {
          setStatus(
            statusEl.textContent +
              "\nNo services found that call at two or more corridor stations in this time range.",
          );
          return;
        }

        // Split into A->B vs B->A, based on order of corridor stations in the calling pattern.
        const split = splitByDirection(allDetails, stations);
        const servicesAB = split.ab;
        const servicesBA = split.ba;

        setStatus(
          statusEl.textContent +
            "\nStep 4/4: Building timetables with " +
            servicesAB.length +
            " A→B services and " +
            servicesBA.length +
            " B→A services across " +
            stations.length +
            " stations ...",
        );

        // Build A -> B table (stations in forward order)
        if (servicesAB.length > 0) {
          headingAB.textContent =
            from + " \u2192 " + to + " (" + servicesAB.length + " services)";
          const modelAB = buildTimetableModel(stations, stationSet, servicesAB);
          renderTimetable(modelAB, headerRowAB, headerIconsRowAB, bodyRowsAB);
        } else {
          headingAB.textContent =
            from + " \u2192 " + to + ": no through services in this time range";
        }

        // Build B -> A table (stations in reverse order)
        if (servicesBA.length > 0) {
          const stationsRev = stations.slice().reverse();
          headingBA.textContent =
            to + " \u2192 " + from + " (" + servicesBA.length + " services)";
          const modelBA = buildTimetableModel(
            stationsRev,
            stationSet,
            servicesBA,
          );
          renderTimetable(modelBA, headerRowBA, headerIconsRowBA, bodyRowsBA);
        } else {
          headingBA.textContent =
            to + " \u2192 " + from + ": no through services in this time range";
        }
      });

      // Build station union over a possibly multi-via corridor.
      // corridorStations is e.g. ["SHR", "VIA1", "VIA2", "WRX"].
      function buildStationsUnion(corridorStations, servicesWithDetails) {
        const stationMap = {};
        const corridorIndex = {};

        // Map each corridor CRS to its index in the chain (A=0, VIA1=1, ..., Z=n)
        corridorStations.forEach((crs, idx) => {
          if (crs) corridorIndex[crs] = idx;
        });

        function addStation(crs, tiploc, name, pos) {
          if (!crs) return;
          const key = crs;
          if (!stationMap[key]) {
            stationMap[key] = {
              crs,
              tiploc: tiploc || "",
              name: name || crs,
              positions: [],
            };
          }
          stationMap[key].positions.push(pos);
        }

        servicesWithDetails.forEach(({ detail }) => {
          const locs = detail.locations || [];
          if (!locs.length) return;

          // All corridor hits for this service: list of { i, corridorIdx }
          const hits = [];
          for (let i = 0; i < locs.length; i++) {
            const crs = locs[i].crs || "";
            if (
              crs &&
              Object.prototype.hasOwnProperty.call(corridorIndex, crs)
            ) {
              hits.push({ i, corridorIdx: corridorIndex[crs] });
            }
          }
          if (hits.length === 0) return;

          // For each adjacent pair of corridor hits, walk the segment between them
          for (let h = 0; h < hits.length - 1; h++) {
            const { i: i1, corridorIdx: c1 } = hits[h];
            const { i: i2, corridorIdx: c2 } = hits[h + 1];
            if (i1 === i2) continue;

            const step = i1 < i2 ? 1 : -1;
            const span = Math.abs(i2 - i1);

            for (let i = i1; step > 0 ? i <= i2 : i >= i2; i += step) {
              const l = locs[i];
              if (!l) continue;
              const disp = (l.displayAs || "").toUpperCase();
              if (disp === "PASS" || disp === "CANCELLED_PASS") continue; // only calling points

              const crs = l.crs || "";
              if (!crs) continue;
              const tiploc = l.tiploc || "";
              const name = l.description || crs || tiploc;

              let pos;
              if (Object.prototype.hasOwnProperty.call(corridorIndex, crs)) {
                // Corridor station itself -> exact integer corridor index
                pos = corridorIndex[crs];
              } else {
                // Off-corridor station: interpolate between the two corridor stations
                const offset = Math.abs(i - i1);
                const frac = span === 0 ? 0 : offset / span;
                pos = c1 + (c2 - c1) * frac; // fractional position between corridor indices
              }

              addStation(crs, tiploc, name, pos);
            }
          }
        });

        const stations = Object.values(stationMap);
        stations.forEach((s) => {
          const sum = s.positions.reduce((a, b) => a + b, 0);
          s.avgPos = sum / s.positions.length;
        });
        stations.sort((a, b) => a.avgPos - b.avgPos);
        return stations;
      }

      function splitByDirection(servicesWithDetails, stations) {
        const ab = [];
        const ba = [];

        // Map CRS to corridor order index (0..N-1) based on stations array
        const crsToOrderIdx = {};
        stations.forEach((s, i) => {
          if (s.crs) crsToOrderIdx[s.crs] = i;
        });

        servicesWithDetails.forEach((entry) => {
          const locs = entry.detail.locations || [];
          const corridorOrderIndices = [];

          // Collect the corridor order indices for every corridor station this service calls at
          for (const l of locs) {
            const crs = l.crs || "";
            if (crs in crsToOrderIdx) {
              corridorOrderIndices.push(crsToOrderIdx[crs]);
            }
          }

          if (corridorOrderIndices.length < 2) {
            // Shouldn't normally happen because we already required >=2 corridor calls,
            // but if it does, just treat it as A→B by default so it appears somewhere.
            ab.push(entry);
            return;
          }

          const first = corridorOrderIndices[0];
          const last = corridorOrderIndices[corridorOrderIndices.length - 1];

          if (first <= last) {
            ab.push(entry);
          } else {
            ba.push(entry);
          }
        });

        return { ab, ba };
      }

      function checkMonotonicTimes(rows, orderedSvcIndices) {
        orderedSvcIndices.forEach((svcIndex) => {
          let dayOffset = 0; // minutes added for midnight rollovers
          let prevAbs = null; // previous absolute time in minutes

          for (let r = 0; r < rows.length; r++) {
            const val = rows[r].cells[svcIndex];

            if (!val) continue;
            if (typeof val === "string" && val.startsWith("<i")) continue; // skip from/to italics

            const mins = timeStrToMinutes(val); // "HH:MM" -> 0..1439
            if (mins === null) continue;

            let base = mins + dayOffset;

            // If this appears to go backwards, treat it as a midnight rollover
            if (prevAbs !== null && base < prevAbs) {
              // allow multiple midnights in pathological cases (up to a few days)
              let safety = 0;
              while (base <= prevAbs && safety < 5) {
                dayOffset += 1440;
                base = mins + dayOffset;
                safety++;
              }
            }

            // If it's STILL going backwards, assert-fail in console
            if (prevAbs !== null && base < prevAbs) {
              console.assert(
                false,
                "Time order assertion failed for service column",
                {
                  svcIndex,
                  rowIndex: r,
                  previousAbsoluteMinutes: prevAbs,
                  currentAbsoluteMinutes: base,
                  currentCellValue: val,
                },
              );
              break; // stop checking this service; we've already flagged it
            }

            prevAbs = base;
          }
        });
      }

      function buildTimetableModel(stations, stationSet, servicesWithDetails) {
        const numServices = servicesWithDetails.length;

        // --- Decide which stations actually get rows (only those with at least one PUBLIC call) ---
        const displayStations = stations.filter((station) => {
          return servicesWithDetails.some(({ detail }) => {
            const locs = detail.locations || [];
            return locs.some((locEntry) => {
              if ((locEntry.crs || "") !== station.crs) return false;
              const disp = (locEntry.displayAs || "").toUpperCase();
              const isPublic = locEntry.isPublicCall === true;
              if (disp === "PASS" || disp === "CANCELLED_PASS") return false;
              return isPublic;
            });
          });
        });

        if (DEBUG_STATIONS) {
          const hidden = stations
            .filter((st) => !displayStations.includes(st))
            .map((st) => ({ crs: st.crs, name: st.name }));
          console.log(
            "Display stations:",
            displayStations.map((s) => s.crs + " " + s.name),
          );
          console.log(
            "Hidden stations (no public calls in any included service):",
            hidden,
          );
        }

        const numStations = displayStations.length;

        // --- Precompute per-station, per-service arrival/departure times ---
        // stationTimes[stationIndex][svcIndex] = { arrStr, arrMins, depStr, depMins }
        const stationTimes = [];
        for (let i = 0; i < numStations; i++) {
          const row = [];
          for (let s = 0; s < numServices; s++) {
            row.push({ arrStr: "", arrMins: null, depStr: "", depMins: null });
          }
          stationTimes.push(row);
        }

        servicesWithDetails.forEach(({ detail }, svcIndex) => {
          const locs = detail.locations || [];

          displayStations.forEach((station, stationIndex) => {
            const loc = locs.find(
              (locEntry) => (locEntry.crs || "") === station.crs,
            );
            if (!loc) return;

            const rawArr = loc.gbttBookedArrival || loc.realtimeArrival || "";
            const rawDep =
              loc.gbttBookedDeparture || loc.realtimeDeparture || "";

            const arrStr = rawArr ? padTime(rawArr) : "";
            const depStr = rawDep ? padTime(rawDep) : "";

            const arrMins = arrStr ? timeStrToMinutes(arrStr) : null;
            const depMins = depStr ? timeStrToMinutes(depStr) : null;

            stationTimes[stationIndex][svcIndex] = {
              arrStr,
              arrMins,
              depStr,
              depMins,
            };
          });
        });

        // --- Decide row mode per station (merged vs two rows vs single) ---
        const stationModes = [];

        for (let i = 0; i < numStations; i++) {
          const times = stationTimes[i];

          let hasArr = false;
          let hasDep = false;
          let hasAny = false;

          let hasLongDwell = false;
          const dwellDebugEntries = [];

          for (let s = 0; s < numServices; s++) {
            const t = times[s];
            if (!t) continue;

            const svc = servicesWithDetails[s].svc;
            const trainId =
              svc.trainIdentity ||
              svc.runningIdentity ||
              svc.serviceUid ||
              "svc#" + s;

            if (t.arrMins !== null) {
              hasArr = true;
              hasAny = true;
            }
            if (t.depMins !== null) {
              hasDep = true;
              hasAny = true;
            }

            if (t.arrMins !== null && t.depMins !== null) {
              const dwellMinutes = Math.abs(t.depMins - t.arrMins);

              if (dwellMinutes > 2) {
                hasLongDwell = true;
              }

              if (DEBUG_STATIONS) {
                dwellDebugEntries.push({
                  svcIndex: s,
                  trainId,
                  arrTimeStr: t.arrStr,
                  depTimeStr: t.depStr,
                  arrMins: t.arrMins,
                  depMins: t.depMins,
                  dwellMinutes,
                });
              }
            } else if (
              DEBUG_STATIONS &&
              (t.arrMins !== null || t.depMins !== null)
            ) {
              dwellDebugEntries.push({
                svcIndex: s,
                trainId,
                arrTimeStr: t.arrStr,
                depTimeStr: t.depStr,
                arrMins: t.arrMins,
                depMins: t.depMins,
                dwellMinutes: null,
              });
            }
          }

          let mode;
          if (hasArr && hasDep) {
            if (hasLongDwell) {
              mode = "two";

              if (DEBUG_STATIONS) {
                const station = displayStations[i];
                const offenders = dwellDebugEntries.filter(
                  (e) => e.dwellMinutes !== null && e.dwellMinutes > 2,
                );

                console.groupCollapsed(
                  "[DWELL] Station not merged:",
                  station.crs,
                  station.name,
                  "— at least one service has dwell > 2 mins",
                );
                console.log(
                  "All services' arr/dep at this station:",
                  dwellDebugEntries,
                );
                console.log("Offending services (dwell > 2 mins):", offenders);
                console.groupEnd();
              }
            } else {
              mode = "merged";

              if (DEBUG_STATIONS) {
                const station = displayStations[i];
                console.groupCollapsed(
                  "[DWELL] Station merged:",
                  station.crs,
                  station.name,
                  "— all dwells <= 2 mins",
                );
                console.log(
                  "All services' arr/dep at this station:",
                  dwellDebugEntries,
                );
                console.groupEnd();
              }
            }
          } else if (hasAny) {
            mode = "single";

            if (DEBUG_STATIONS) {
              const station = displayStations[i];
              console.groupCollapsed(
                "[DWELL] Station single-row (only arr OR only dep overall):",
                station.crs,
                station.name,
              );
              console.log(
                "All services' arr/dep at this station:",
                dwellDebugEntries,
              );
              console.groupEnd();
            }
          } else {
            mode = "single";
          }

          stationModes[i] = mode;
        }

        // --- Compute origin/destination meta for services that start/end outside the corridor ---
        // We store:
        //  - display: CRS only
        //  - title: full name only (no "from/to")
        const originMeta = new Array(numServices).fill(null);
        const destMeta = new Array(numServices).fill(null);

        servicesWithDetails.forEach(({ detail }, idx) => {
          const locs = detail.locations || [];
          if (locs.length === 0) return;

          const firstLoc = locs[0];
          const lastLoc = locs[locs.length - 1];

          if (firstLoc) {
            const crs = firstLoc.crs || "";
            if (!stationSet[crs]) {
              const name = firstLoc.description || crs || firstLoc.tiploc || "";
              const crsCode = crs || firstLoc.tiploc || name;
              originMeta[idx] = { display: crsCode, title: name };
            }
          }

          if (lastLoc) {
            const crs = lastLoc.crs || "";
            if (!stationSet[crs]) {
              const name = lastLoc.description || crs || lastLoc.tiploc || "";
              const crsCode = crs || lastLoc.tiploc || name;
              destMeta[idx] = { display: crsCode, title: name };
            }
          }
        });

        // Dedicated extra rows:
        // - Top row: "Comes from" (only if any originMeta exists in this direction)
        // - Bottom row: "Continues to" (only if any destMeta exists in this direction)
        const needTopExtra = originMeta.some((m) => !!m);
        const needBottomExtra = destMeta.some((m) => !!m);

        // --- Helper: build rowSpecs, optionally with top/bottom extra rows ---
        function makeRowSpecs(includeTopExtra, includeBottomExtra) {
          const specs = [];
          if (includeTopExtra) {
            specs.push({
              kind: "extra",
              mode: "comes-from",
              label: "Comes from",
              stationIndex: null,
              arrDepLabel: "",
            });
          }

          for (let i = 0; i < numStations; i++) {
            const mode = stationModes[i];
            if (mode === "two") {
              specs.push({
                kind: "station",
                stationIndex: i,
                mode: "arr",
                arrDepLabel: "arr",
              });
              specs.push({
                kind: "station",
                stationIndex: i,
                mode: "dep",
                arrDepLabel: "dep",
              });
            } else {
              specs.push({
                kind: "station",
                stationIndex: i,
                mode: mode,
                arrDepLabel: "",
              });
            }
          }

          if (includeBottomExtra) {
            specs.push({
              kind: "extra",
              mode: "continues-to",
              label: "Continues to",
              stationIndex: null,
              arrDepLabel: "",
            });
          }

          return specs;
        }

        // --- Helper: init rows + labels for a given rowSpecs ---
        function makeRowsForSpecs(specs) {
          const rows = specs.map((spec) => ({
            kind: spec.kind, // "station" / "extra"
            mode: spec.mode, // "arr"/"dep"/"merged"/"single"/"comes-from"/"continues-to"
            labelStation: "",
            labelArrDep: "",
            cells: new Array(numServices).fill(""),
          }));

          // Label station name only on first row for that station
          let lastStationIndexForLabel = null;
          for (let r = 0; r < specs.length; r++) {
            const spec = specs[r];

            if (spec.kind === "extra") {
              rows[r].labelStation = spec.label || "";
              continue;
            }

            if (spec.kind === "station") {
              const stationIndex = spec.stationIndex;
              const station = displayStations[stationIndex];

              if (stationIndex !== lastStationIndexForLabel) {
                rows[r].labelStation = station.name;
                lastStationIndexForLabel = stationIndex;
              }

              rows[r].labelArrDep = spec.arrDepLabel;
            }
          }

          return rows;
        }

        // --- Helper: fill times + return first/last timing row per service ---
        function fillTimesIntoRows(specs, rows) {
          const firstRowForService = new Array(numServices).fill(null);
          const lastRowForService = new Array(numServices).fill(null);

          for (let r = 0; r < specs.length; r++) {
            const spec = specs[r];
            if (spec.kind !== "station") continue;

            const stationIndex = spec.stationIndex;
            const mode = spec.mode;

            for (let s = 0; s < numServices; s++) {
              const t = stationTimes[stationIndex][s];
              if (!t) continue;

              let timeStr = "";
              if (mode === "arr") {
                timeStr = t.arrStr;
              } else if (mode === "dep") {
                timeStr = t.depStr;
              } else if (mode === "merged" || mode === "single") {
                timeStr = t.depStr || t.arrStr;
              }

              if (timeStr) {
                rows[r].cells[s] = timeStr;
                if (firstRowForService[s] === null || r < firstRowForService[s])
                  firstRowForService[s] = r;
                if (lastRowForService[s] === null || r > lastRowForService[s])
                  lastRowForService[s] = r;
              }
            }
          }

          return { firstRowForService, lastRowForService };
        }

        // --- Build rows with only the extra rows we need (per direction) ---
        let rowSpecs = makeRowSpecs(needTopExtra, needBottomExtra);
        let rows = makeRowsForSpecs(rowSpecs);
        let { firstRowForService, lastRowForService } = fillTimesIntoRows(
          rowSpecs,
          rows,
        );

        const totalRows = rowSpecs.length;

        // --- Put origin/destination CRS into the dedicated extra rows (top/bottom) ---
        const topExtraRowIdx = needTopExtra ? 0 : null;
        const bottomExtraRowIdx = needBottomExtra ? totalRows - 1 : null;

        servicesWithDetails.forEach((entry, svcIndex) => {
          const fromInfo = originMeta[svcIndex];
          const toInfo = destMeta[svcIndex];

          if (fromInfo && topExtraRowIdx !== null) {
            if (!rows[topExtraRowIdx].cells[svcIndex]) {
              rows[topExtraRowIdx].cells[svcIndex] =
                `<i title="${htmlEscape(fromInfo.title)}">${htmlEscape(fromInfo.display)}</i>`;
            }
          }

          if (toInfo && bottomExtraRowIdx !== null) {
            if (!rows[bottomExtraRowIdx].cells[svcIndex]) {
              rows[bottomExtraRowIdx].cells[svcIndex] =
                `<i title="${htmlEscape(toInfo.title)}">${htmlEscape(toInfo.display)}</i>`;
            }
          }
        });

        // === Column ordering ===
        // We insert services row-by-row based on firstRowForService.
        // When inserting a service that starts on a given row, we compare it against
        // existing columns using the *time on that same row*, with this preference:
        //   - use departure time if available
        //   - otherwise use arrival time
        //
        // (If a service has no time on that row at all, it sorts last for that row.)
        function preferredTimeMinsAtRow(serviceIdx, rowIdx) {
          const spec = rowSpecs[rowIdx];
          if (!spec || spec.kind !== "station") return null;

          const stationIndex = spec.stationIndex;
          const t = stationTimes[stationIndex][serviceIdx];
          if (!t) return null;

          // Prefer dep; otherwise arr (even on "arr" rows).
          const timeStr = t.depStr && t.depStr.trim() ? t.depStr : t.arrStr;
          if (!timeStr) return null;

          const mins = timeStrToMinutes(timeStr);
          return mins === null ? null : mins;
        }

        const orderedSvcIndices = [];

        for (let r = 0; r < totalRows; r++) {
          // Services whose first corridor timing row is exactly this row.
          const startingHere = [];
          for (let s = 0; s < numServices; s++) {
            if (firstRowForService[s] === r) {
              startingHere.push({
                index: s,
                timeMins: preferredTimeMinsAtRow(s, r),
              });
            }
          }

          // Sort those by preferred row-time (nulls last, then by original index)
          startingHere.sort((a, b) => {
            if (a.timeMins === null && b.timeMins === null)
              return a.index - b.index;
            if (a.timeMins === null) return 1;
            if (b.timeMins === null) return -1;
            if (a.timeMins !== b.timeMins) return a.timeMins - b.timeMins;
            return a.index - b.index;
          });

          // Insert into orderedSvcIndices relative to existing services, comparing
          // against the existing services' preferred time on *this same row*.
          for (const { index: sIdx, timeMins } of startingHere) {
            if (orderedSvcIndices.length === 0 || timeMins === null) {
              orderedSvcIndices.push(sIdx);
              continue;
            }

            let inserted = false;
            for (let pos = 0; pos < orderedSvcIndices.length; pos++) {
              const existingIdx = orderedSvcIndices[pos];
              const existingTime = preferredTimeMinsAtRow(existingIdx, r);
              if (existingTime === null) continue; // can't compare at this row

              if (timeMins <= existingTime) {
                orderedSvcIndices.splice(pos, 0, sIdx);
                inserted = true;
                break;
              }
            }

            if (!inserted) orderedSvcIndices.push(sIdx);
          }
        }

        // --- Service header metadata (for renderer) ---
        const servicesMeta = servicesWithDetails.map(({ svc, detail }) => {
          const originText = safePairText(detail.origin);
          const destText = safePairText(detail.destination);
          const dateText = detail.runDate || svc.runDate || "";
          const uid = svc.serviceUid || "";
          const date = svc.runDate || detail.runDate || "";
          const href = `https://www.realtimetrains.co.uk/service/gb-nr:${encodeURIComponent(uid)}/${encodeURIComponent(date)}`;

          const headcode =
            svc.trainIdentity || svc.runningIdentity || svc.serviceUid || "";

          const opCode = svc.atocCode || detail.atocCode || "";
          const opName = svc.atocName || detail.atocName || opCode;

          const visible = opCode || headcode || "?";

          const line1Parts = [];
          if (opName) line1Parts.push(opName);
          if (headcode) line1Parts.push(headcode);
          if (dateText) line1Parts.push(dateText);
          const line1 = line1Parts.join(" • ");

          let line2 = "";
          if (originText || destText) {
            line2 = `${originText} → ${destText}`;
          }

          const tooltip =
            line2 && line1 ? `${line1}\n${line2}` : line1 || line2 || visible;

          // === class/sleeper extraction ===
          const tc = (detail.trainClass || "").trim();
          const passenger =
            detail.isPassenger === true || svc.isPassenger !== false;
          const firstClassAvailable =
            passenger && (tc === "" ? true : tc !== "S");

          const sl = (detail.sleepers || "").trim();
          const isSleeper = sl !== "";

          return {
            visible,
            tooltip,
            href,
            firstClassAvailable,
            isSleeper,
          };
        });

        // Assert (in console) that times in each service column never decrease
        // as you go down the table, allowing for midnight rollovers.
        checkMonotonicTimes(rows, orderedSvcIndices);

        return {
          rows,
          orderedSvcIndices,
          servicesMeta,
        };
      }

      // === Rendering: turn model into DOM ===
      function renderTimetable(
        model,
        headerRowEl,
        headerIconsRowEl,
        bodyRowsEl,
      ) {
        const { rows, orderedSvcIndices, servicesMeta } = model;

        headerRowEl.innerHTML = "";
        headerIconsRowEl.innerHTML = "";
        bodyRowsEl.innerHTML = "";

        // --- Build headers row (existing) ---
        const thStation = document.createElement("th");
        thStation.classList.add("sticky-top", "sticky-left", "corner");
        thStation.textContent = "Station";
        headerRowEl.appendChild(thStation);

        orderedSvcIndices.forEach((svcIndex) => {
          const meta = servicesMeta[svcIndex];
          const th = document.createElement("th");
          th.classList.add("sticky-top");

          const tooltipEsc = htmlEscape(meta.tooltip);
          const visibleEsc = htmlEscape(meta.visible);
          const href = meta.href || "";

          if (href) {
            th.innerHTML = `
        <a class="service-header"
           href="${href}"
           target="_blank"
           rel="noopener noreferrer"
           title="${tooltipEsc}">${visibleEsc}</a>
      `;
          } else {
            th.innerHTML = `<span class="service-header" title="${tooltipEsc}">${visibleEsc}</span>`;
          }

          headerRowEl.appendChild(th);
        });

        // --- Build icons row ---
        const thStationIcons = document.createElement("th");
        thStationIcons.classList.add("sticky-left", "corner", "icon-row");
        thStationIcons.textContent = "Facilities"; // blank under "Station"
        headerIconsRowEl.appendChild(thStationIcons);

        function bedSvg() {
          // simple inline SVG bed icon (currentColor stroke/fill)
          return `
      <span class="bed-icon" title="Sleeper" aria-label="Sleeper">
  <svg viewBox="0 0 24 24" role="img" focusable="false" aria-hidden="true">
    <!-- headboard + left leg (single stroke) -->
    <path d="M4 6v14" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"/>

    <!-- mattress -->
    <path d="M4 12h16a2 2 0 0 1 2 2v4H4z"
          fill="none" stroke="currentColor" stroke-width="2" stroke-linejoin="round"/>

    <!-- pillow (simple) -->
    <path d="M7 10h4a2 2 0 0 1 2 2H7a2 2 0 0 1-2-2a2 2 0 0 1 2-2z"
          fill="none" stroke="currentColor" stroke-width="2" stroke-linejoin="round"/>

    <!-- right leg at end of mattress -->
    <path d="M20 20v-2" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"/>
  </svg>
</span>

    `;
        }

        orderedSvcIndices.forEach((svcIndex) => {
          const meta = servicesMeta[svcIndex];

          const th = document.createElement("th");
          th.classList.add("icon-row");

          const icons = [];
          if (meta.firstClassAvailable) {
            icons.push(
              `<span class="fc-icon" title="First class available" aria-label="First class available">1</span>`,
            );
          }
          if (meta.isSleeper) {
            icons.push(bedSvg());
          }

          th.innerHTML = icons.length
            ? `<span class="icon-wrap">${icons.join("")}</span>`
            : "";
          headerIconsRowEl.appendChild(th);
        });

        // --- Render body rows (unchanged) ---
        rows.forEach((row, rowIdx) => {
          const tr = document.createElement("tr");

          if (rowIdx === 0) tr.classList.add("row-sep-top");
          if (row.kind === "station" && row.labelArrDep === "dep")
            tr.classList.add("row-sep-top");

          const prevRow = rowIdx > 0 ? rows[rowIdx - 1] : null;
          if (prevRow) {
            const boundaryExtraToStation =
              prevRow.kind === "extra" && row.kind === "station";
            const boundaryStationToExtra =
              prevRow.kind === "station" && row.kind === "extra";
            if (boundaryExtraToStation || boundaryStationToExtra) {
              tr.classList.add("row-sep-top");
            }
          }

          let labelText = "";
          if (row.labelStation && row.labelArrDep)
            labelText = row.labelStation + " (" + row.labelArrDep + ")";
          else if (row.labelStation) labelText = row.labelStation;
          else if (!row.labelStation && row.labelArrDep)
            labelText = "(" + row.labelArrDep + ")";

          const labelTd = document.createElement("td");
          labelTd.classList.add("sticky-left", "station-row-label");
          labelTd.textContent = labelText;
          tr.appendChild(labelTd);

          orderedSvcIndices.forEach((svcIndex) => {
            const val = row.cells[svcIndex];
            const td = document.createElement("td");
            if (val && val.startsWith("<i")) {
              td.innerHTML = val;
            } else {
              td.textContent = val;
              if (!val) td.classList.add("time-empty");
            }
            tr.appendChild(td);
          });

          bodyRowsEl.appendChild(tr);
        });
      }
    </script>
  </body>
</html>
